"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const datasource_toolkit_1 = require("@forestadmin/datasource-toolkit");
const filterable_1 = __importDefault(require("../agent/utils/forest-schema/filterable"));
class CollectionBuilder {
    constructor(stack, name) {
        this.name = name;
        this.stack = stack;
    }
    /**
     * Disable count in list view pagination for improved performance.
     *
     * @example
     * .disableCount()
     */
    disableCount() {
        this.stack.schema.getCollection(this.name).overrideSchema({ countable: false });
        return this;
    }
    /**
     * Import a field from a many to one or one to one relation.
     *
     * @param name the name of the field that will be created on the collection
     * @param options options to import the field
     * @example
     * .importField('authorName', { path: 'author:fullName' })
     */
    importField(name, options) {
        const collection = this.stack.lateComputed.getCollection(this.name);
        const schema = datasource_toolkit_1.CollectionUtils.getFieldSchema(collection, options.path);
        this.addField(name, {
            beforeRelations: options.beforeRelations,
            columnType: schema.columnType,
            defaultValue: schema.defaultValue,
            dependencies: [options.path],
            getValues: records => records.map(r => datasource_toolkit_1.RecordUtils.getFieldValue(r, options.path)),
            enumValues: schema.enumValues,
        });
        if (!schema.isReadOnly && !options.readonly) {
            this.stack.write.getCollection(this.name).replaceFieldWriting(name, value => {
                const path = options.path.split(':');
                const writingPath = {};
                path.reduce((nestedPath, currentPath, index) => {
                    nestedPath[currentPath] = index === path.length - 1 ? value : {};
                    return nestedPath[currentPath];
                }, writingPath);
                return writingPath;
            });
        }
        if (schema.isReadOnly && options.readonly === false) {
            throw new Error(`Readonly option should not be false because the field "${options.path}" is not writable`);
        }
        for (const operator of schema.filterOperators) {
            const handler = value => ({ field: options.path, operator, value });
            this.replaceFieldOperator(name, operator, handler);
        }
        if (schema.isSortable) {
            this.replaceFieldSorting(name, [
                { field: options.path, ascending: true },
            ]);
        }
        return this;
    }
    /**
     * Allow to rename a field of a given collection.
     * @param oldName the current name of the field in a given collection
     * @param newName the new name of the field
     * @example
     * .renameField('theCurrentNameOfTheField', 'theNewNameOfTheField');
     */
    renameField(oldName, newName) {
        this.stack.renameField.getCollection(this.name).renameField(oldName, newName);
        return this;
    }
    /**
     * Remove field by setting its visibility to false.
     * @param names the fields to remove
     * @example
     * .removeField('aFieldToRemove', 'anotherFieldToRemove');
     */
    removeField(...names) {
        const collection = this.stack.publication.getCollection(this.name);
        for (const name of names)
            collection.changeFieldVisibility(name, false);
        return this;
    }
    /**
     * Add a new action on the collection.
     * @param name the name of the action
     * @param definition the definition of the action
     * @example
     * .addAction('is live', {
     *    scope: 'Single',
     *    execute: async (context, resultBuilder) => {
     *      return resultBuilder.success(`Is live!`);
     *    },
     *  })
     */
    addAction(name, definition) {
        this.stack.action
            .getCollection(this.name)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .addAction(name, definition);
        return this;
    }
    /**
     * Add a new field on the collection.
     * @param name the name of the field
     * @param definition The definition of the field
     * @example
     * .addField('fullName', {
     *    columnType: 'String',
     *    dependencies: ['firstName', 'lastName'],
     *    getValues: (records) => records.map(record => `${record.lastName} ${record.firstName}`),
     * });
     */
    addField(name, definition) {
        const { beforeRelations, ...computedDefinition } = definition;
        const collection = definition.beforeRelations
            ? this.stack.earlyComputed.getCollection(this.name)
            : this.stack.lateComputed.getCollection(this.name);
        collection.registerComputed(name, computedDefinition);
        return this;
    }
    /**
     * Add a many to one relation to the collection
     * @param name name of the new relation
     * @param foreignCollection name of the targeted collection
     * @param options extra information about the relation
     * @example
     * books.addManyToOneRelation('myAuthor', 'persons', { foreignKey: 'authorId' })
     */
    addManyToOneRelation(name, foreignCollection, options) {
        this.addRelation(name, {
            type: 'ManyToOne',
            foreignCollection,
            foreignKey: options.foreignKey,
            foreignKeyTarget: options.foreignKeyTarget,
        });
        return this;
    }
    /**
     * Add a one to many relation to the collection
     * @param name name of the new relation
     * @param foreignCollection name of the targeted collection
     * @param options extra information about the relation
     * @example
     * persons.addOneToManyRelation('writtenBooks', 'books', { originKey: 'authorId' })
     */
    addOneToManyRelation(name, foreignCollection, options) {
        this.addRelation(name, {
            type: 'OneToMany',
            foreignCollection,
            originKey: options.originKey,
            originKeyTarget: options.originKeyTarget,
        });
        return this;
    }
    /**
     * Add a one to one relation to the collection
     * @param name name of the new relation
     * @param foreignCollection name of the targeted collection
     * @param options extra information about the relation
     * @example
     * persons.addOneToOneRelation('bestFriend', 'persons', { originKey: 'bestFriendId' })
     */
    addOneToOneRelation(name, foreignCollection, options) {
        this.addRelation(name, {
            type: 'OneToOne',
            foreignCollection,
            originKey: options.originKey,
            originKeyTarget: options.originKeyTarget,
        });
        return this;
    }
    /**
     * Add a many to many relation to the collection
     * @param name name of the new relation
     * @param foreignCollection name of the targeted collection
     * @param throughCollection name of the intermediary collection
     * @param options extra information about the relation
     * @example
     * dvds.addManyToManyRelation('rentalsOfThisDvd', 'rentals', 'dvdRentals', {
     *   originKey: 'dvdId',
     *   foreignKey: 'rentalId'
     * })
     */
    addManyToManyRelation(name, foreignCollection, throughCollection, options) {
        this.addRelation(name, {
            type: 'ManyToMany',
            foreignCollection,
            throughCollection,
            originKey: options.originKey,
            originKeyTarget: options.originKeyTarget,
            foreignKey: options.foreignKey,
            foreignKeyTarget: options.foreignKeyTarget,
        });
        return this;
    }
    /**
     * Add a virtual collection into the related data of a record.
     *
     * @param name name of the relation
     * @param definition the definition of the new relation
     * @example
     * .addExternalRelation('states', {
     *   schema: { code: 'Number', name: 'String' },
     *   listRecords: ({ id }) => {
     *     return record.id == 34 ?
     *      [{ code: 'AL', name: 'Alabama' }, { code: 'AK', name: 'Alaska' }] :
     *      [{ code: 'AZ', name: 'Arizona' }, { code: 'TX', name: 'Texas' }];
     *   }
     * })
     */
    addExternalRelation(name, definition) {
        const { schema } = this.stack.action.getCollection(this.name);
        const primaryKeys = datasource_toolkit_1.SchemaUtils.getPrimaryKeys(schema);
        return this.addField(name, {
            dependencies: definition.dependencies ?? primaryKeys,
            columnType: [definition.schema],
            getValues: async (records, context) => Promise.all(records.map(async (record) => definition.listRecords(record, context))),
        });
    }
    /**
     * Add a new segment on the collection.
     * @param name the name of the segment
     * @param definition a function used to generate a condition tree
     * or a condition tree
     * @example
     * .addSegment(
     *    'Wrote more than 2 books',
     *    { field: 'booksCount', operator: 'GreaterThan', value: 2 }
     * );
     */
    addSegment(name, definition) {
        this.stack.segment.getCollection(this.name).addSegment(name, definition);
        return this;
    }
    /**
     * Enable sorting on a specific field using emulation.
     * As for all the emulation method, the field sorting will be done in-memory.
     * @param name the name of the field to enable emulation on
     * @example
     * .emulateFieldSorting('fullName');
     */
    emulateFieldSorting(name) {
        this.stack.sortEmulate.getCollection(this.name).emulateFieldSorting(name);
        return this;
    }
    /**
     * Replace an implementation for the sorting.
     * The field sorting will be done by the datasource.
     * @param name the name of the field to enable sort
     * @param equivalentSort the sort equivalent
     * @example
     * .replaceFieldSorting(
     *   'fullName',
     *   [
     *     { field: 'firstName', ascending: true },
     *     { field: 'lastName',  ascending: true },
     *   ]
     * )
     */
    replaceFieldSorting(name, equivalentSort) {
        this.stack.sortEmulate
            .getCollection(this.name)
            .replaceFieldSorting(name, equivalentSort);
        return this;
    }
    /**
     * Enable filtering on a specific field using emulation.
     * As for all the emulation method, the field filtering will be done in-memory.
     * @param name the name of the field to enable emulation on
     * @example
     * .emulateFieldFiltering('aField');
     */
    emulateFieldFiltering(name) {
        const collection = this.stack.lateOpEmulate.getCollection(this.name);
        const field = collection.schema.fields[name];
        for (const operator of filterable_1.default.getRequiredOperators(field.columnType)) {
            if (!field.filterOperators?.has(operator)) {
                this.emulateFieldOperator(name, operator);
            }
        }
        return this;
    }
    /**
     * Enable filtering on a specific field with a specific operator using emulation.
     * As for all the emulation method, the field filtering will be done in-memory.
     * @param name the name of the field to enable emulation on
     * @param operator the operator to emulate
     * @example
     * .emulateFieldOperator('aField', 'In');
     */
    emulateFieldOperator(name, operator) {
        const collection = this.stack.earlyOpEmulate.getCollection(this.name).schema.fields[name]
            ? this.stack.earlyOpEmulate.getCollection(this.name)
            : this.stack.lateOpEmulate.getCollection(this.name);
        collection.emulateFieldOperator(name, operator);
        return this;
    }
    /**
     * Replace an implementation for a specific operator on a specific field.
     * The operator replacement will be done by the datasource.
     * @param name the name of the field to filter on
     * @param operator the operator to replace
     * @param replacer the proposed implementation
     * @example
     * .replaceFieldOperator('fullName', 'Contains', (value) => {
     *    return {
     *      aggregator: 'Or',
     *      conditions: [{
     *        field: 'firstName',
     *        operator: 'Contains',
     *        value
     *      }, {
     *        field: 'lastName',
     *        operator: 'Contains',
     *        value
     *      }]
     *    }
     * });
     */
    replaceFieldOperator(name, operator, replacer) {
        const collection = this.stack.earlyOpEmulate.getCollection(this.name).schema.fields[name]
            ? this.stack.earlyOpEmulate.getCollection(this.name)
            : this.stack.lateOpEmulate.getCollection(this.name);
        collection.replaceFieldOperator(name, operator, replacer);
        return this;
    }
    /**
     * Replace the write behavior of a field.
     * @param name the name of the field
     * @param definition the function or a value to represent the write behavior
     * @example
     * .replaceFieldWriting('fullName', fullName => {
     *   const [firstName, lastName] = fullName.split(' ');
     *   return { firstName, lastName };
     * });
     */
    replaceFieldWriting(name, definition) {
        this.stack.write.getCollection(this.name).replaceFieldWriting(name, definition);
        return this;
    }
    /**
     * Replace the behavior of the search bar
     * @param definition handler to describe the new behavior
     * @example
     * .replaceSearch(async (searchString) => {
     *   return { field: 'name', operator: 'Contains', value: searchString };
     * });
     */
    replaceSearch(definition) {
        this.stack.search
            .getCollection(this.name)
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .replaceSearch(definition);
        return this;
    }
    addHook(position, type, handler) {
        this.stack.hook
            .getCollection(this.name)
            .addHook(position, type, handler);
        return this;
    }
    /**
     * Add a relation between two collections.
     * @param name name of the new relation
     * @param definition definition of the new relation
     * @example
     * .addRelation('author', {
     *   type: 'ManyToOne',
     *   foreignCollection: 'persons',
     *   foreignKey: 'authorId'
     * });
     */
    addRelation(name, definition) {
        this.stack.relation.getCollection(this.name).addRelation(name, definition);
        return this;
    }
}
exports.default = CollectionBuilder;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29sbGVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9idWlsZGVyL2NvbGxlY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSx3RUFxQnlDO0FBSXpDLHlGQUE4RTtBQUU5RSxNQUFxQixpQkFBaUI7SUFPcEMsWUFBWSxLQUFzQixFQUFFLElBQVk7UUFDOUMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDckIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsWUFBWTtRQUNWLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsY0FBYyxDQUFDLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7UUFFaEYsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILFdBQVcsQ0FDVCxJQUFZLEVBQ1osT0FBa0Y7UUFFbEYsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNwRSxNQUFNLE1BQU0sR0FBRyxvQ0FBZSxDQUFDLGNBQWMsQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLElBQUksQ0FBaUIsQ0FBQztRQUV4RixJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRTtZQUNsQixlQUFlLEVBQUUsT0FBTyxDQUFDLGVBQWU7WUFDeEMsVUFBVSxFQUFFLE1BQU0sQ0FBQyxVQUFVO1lBQzdCLFlBQVksRUFBRSxNQUFNLENBQUMsWUFBWTtZQUNqQyxZQUFZLEVBQUUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1lBQzVCLFNBQVMsRUFBRSxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVB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