import { ChartDefinition, DataSourceFactory, TCollectionName, TSchema } from '@forestadmin/datasource-toolkit';
import { AgentOptions } from '../types';
import { DataSourceOptions } from './types';
import CollectionBuilder from './collection';
/**
 * Allow to create a new Forest Admin agent from scratch.
 * Builds the application by composing and configuring all the collection decorators.
 *
 * Minimal code to add a datasource
 * @example
 * new AgentBuilder(options)
 *  .addDataSource(new SomeDataSource())
 *  .start();
 */
export default class AgentBuilder<S extends TSchema = TSchema> {
    private readonly compositeDataSource;
    private readonly stack;
    private readonly options;
    private customizations;
    private mounts;
    private termination;
    /**
     * Create a new Agent Builder.
     * If any options are missing, the default will be applied:
     * ```
     *  clientId: null,
     *  forestServerUrl: 'https://api.forestadmin.com',
     *  logger: (level, data) => console.error(level, data),
     *  prefix: 'api/v1',
     *  schemaPath: '.forestadmin-schema.json',
     *  permissionsCacheDurationInSeconds: 15 * 60,
     * ```
     * @param options options
     * @example
     * new AgentBuilder(options)
     *  .addDataSource(new DataSource())
     *  .start();
     */
    constructor(options: AgentOptions);
    /**
     * Add a datasource
     * @param factory the datasource to add
     * @param options the options
     */
    addDataSource(factory: DataSourceFactory, options?: DataSourceOptions): this;
    /**
     * Create a new API chart
     * @param name name of the chart
     * @param definition definition of the chart
     * @example
     * .addChart('numCustomers', {
     *   type: 'Value',
     *   render: (context, resultBuilder) => {
     *     return resultBuilder.value(123);
     *   }
     * })
     */
    addChart(name: string, definition: ChartDefinition<S>): this;
    /**
     * Allow to interact with a decorated collection
     * @param name the name of the collection to manipulate
     * @param handle a function that provide a
     *   collection builder on the given collection name
     * @example
     * .customizeCollection('books', books => books.renameField('xx', 'yy'))
     */
    customizeCollection<N extends TCollectionName<S>>(name: N, handle: (collection: CollectionBuilder<S, N>) => unknown): this;
    /**
     * Expose the agent on a given port and host
     * @param port port that should be used.
     * @param host host that should be used.
     */
    mountOnStandaloneServer(port?: number, host?: string): this;
    /**
     * Mount the agent on an express app.
     * @param express instance of the express app or router.
     */
    mountOnExpress(express: any): this;
    /**
     * Mount the agent on a fastify app
     * @param fastify instance of the fastify app, or of a fastify context
     */
    mountOnFastify(fastify: any): this;
    /**
     * Mount the agent on a koa app
     * @param koa instance of a koa app or a koa Router.
     */
    mountOnKoa(koa: any): this;
    /**
     * Mount the agent on a NestJS app
     * @param nestJs instance of a NestJS application
     */
    mountOnNestJs(nestJs: any): this;
    /**
     * Start the agent.
     */
    start(): Promise<void>;
    stop(): Promise<void>;
    /** Compute the prefix that the main router should be mounted at in the client's application */
    private get completeMountPrefix();
    private useCallbackOnFastify;
    private getConnectCallback;
}
//# sourceMappingURL=agent.d.ts.map