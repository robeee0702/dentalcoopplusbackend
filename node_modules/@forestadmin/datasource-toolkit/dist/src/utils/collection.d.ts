import { Caller } from '../interfaces/caller';
import { Collection } from '../interfaces/collection';
import { CompositeId, RecordData } from '../interfaces/record';
import { FieldSchema } from '../interfaces/schema';
import Aggregation, { AggregateResult } from '../interfaces/query/aggregation';
import Filter from '../interfaces/query/filter/unpaginated';
import PaginatedFilter from '../interfaces/query/filter/paginated';
import Projection from '../interfaces/query/projection';
export default class CollectionUtils {
    static getFieldSchema(collection: Collection, path: string): FieldSchema;
    static getInverseRelation(collection: Collection, relationName: string): string;
    static getThroughOrigin(collection: Collection, relationName: string): string;
    static getThroughTarget(collection: Collection, relationName: string): string;
    static listRelation(collection: Collection, id: CompositeId, relationName: string, caller: Caller, foreignFilter: PaginatedFilter, projection: Projection): Promise<RecordData[]>;
    static aggregateRelation(collection: Collection, id: CompositeId, relationName: string, caller: Caller, foreignFilter: Filter, aggregation: Aggregation, limit?: number): Promise<AggregateResult[]>;
    static getValue(collection: Collection, caller: Caller, id: CompositeId, field: string): Promise<unknown>;
}
//# sourceMappingURL=collection.d.ts.map