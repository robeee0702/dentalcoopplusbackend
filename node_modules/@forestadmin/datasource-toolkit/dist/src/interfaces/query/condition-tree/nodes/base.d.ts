import { AsyncLeafReplacer, LeafCallback, LeafReplacer, LeafTester, PlainConditionTreeLeaf } from './leaf';
import { Collection } from '../../../collection';
import { PlainConditionTreeBranch } from './branch';
import { RecordData } from '../../../record';
import { TCollectionName, TSchema } from '../../../templates';
import Projection from '../../projection';
export declare type PlainConditionTree<S extends TSchema = TSchema, N extends TCollectionName<S> = TCollectionName<S>> = PlainConditionTreeBranch<S, N> | PlainConditionTreeLeaf<S, N>;
export default abstract class ConditionTree {
    abstract inverse(): ConditionTree;
    abstract replaceLeafs(handler: LeafReplacer, bind?: unknown): ConditionTree;
    abstract replaceLeafsAsync(handler: AsyncLeafReplacer, bind?: unknown): Promise<ConditionTree>;
    abstract match(record: RecordData, collection: Collection, timezone: string): boolean;
    abstract forEachLeaf(handler: LeafCallback): void;
    abstract everyLeaf(handler: LeafTester): boolean;
    abstract someLeaf(handler: LeafTester): boolean;
    abstract get projection(): Projection;
    apply(records: RecordData[], collection: Collection, timezone: string): RecordData[];
    nest(prefix: string): ConditionTree;
    unnest(): ConditionTree;
    replaceFields(handler: (field: string) => string): ConditionTree;
}
//# sourceMappingURL=base.d.ts.map