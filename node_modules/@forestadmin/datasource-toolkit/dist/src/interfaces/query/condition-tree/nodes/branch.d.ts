import { AsyncLeafReplacer, LeafCallback, LeafReplacer, LeafTester, PlainConditionTreeLeaf } from './leaf';
import { Collection } from '../../../collection';
import { RecordData } from '../../../record';
import { TCollectionName, TSchema } from '../../../templates';
import ConditionTree from './base';
import Projection from '../../projection';
export declare type Aggregator = 'And' | 'Or';
export declare type PlainConditionTreeBranch<S extends TSchema = TSchema, N extends TCollectionName<S> = TCollectionName<S>> = {
    aggregator: Aggregator;
    conditions: Array<PlainConditionTreeBranch<S, N> | PlainConditionTreeLeaf<S, N>>;
};
export default class ConditionTreeBranch extends ConditionTree {
    aggregator: Aggregator;
    conditions: ConditionTree[];
    get projection(): Projection;
    constructor(aggregator: Aggregator, conditions: ConditionTree[]);
    forEachLeaf(handler: LeafCallback): void;
    everyLeaf(handler: LeafTester): boolean;
    someLeaf(handler: LeafTester): boolean;
    inverse(): ConditionTree;
    replaceLeafs(handler: LeafReplacer, bind?: unknown): ConditionTree;
    replaceLeafsAsync(handler: AsyncLeafReplacer, bind?: unknown): Promise<ConditionTree>;
    match(record: RecordData, collection: Collection, timezone: string): boolean;
}
//# sourceMappingURL=branch.d.ts.map