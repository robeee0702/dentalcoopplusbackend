import { Collection } from '../../../collection';
import { Operator } from './operators';
import { RecordData } from '../../../record';
import { TCollectionName, TFieldName, TSchema } from '../../../templates';
import ConditionTree, { PlainConditionTree } from './base';
import Projection from '../../projection';
export declare type PlainConditionTreeLeaf<S extends TSchema = TSchema, N extends TCollectionName<S> = TCollectionName<S>> = {
    field: TFieldName<S, N>;
    operator: Operator;
    value?: unknown;
};
declare type LeafHandler<R> = (leaf: ConditionTreeLeaf) => R;
export declare type LeafReplacer = LeafHandler<ConditionTree | PlainConditionTree>;
export declare type AsyncLeafReplacer = LeafHandler<Promise<ConditionTree | PlainConditionTree>>;
export declare type LeafTester = LeafHandler<boolean>;
export declare type LeafCallback = LeafHandler<void>;
export default class ConditionTreeLeaf extends ConditionTree {
    field: string;
    operator: Operator;
    value?: unknown;
    get projection(): Projection;
    get useIntervalOperator(): boolean;
    constructor(field: string, operator: Operator, value?: unknown);
    forEachLeaf(handler: LeafCallback): void;
    everyLeaf(handler: LeafTester): boolean;
    someLeaf(handler: LeafTester): boolean;
    inverse(): ConditionTree;
    replaceLeafs(handler: LeafReplacer, bind?: unknown): ConditionTree;
    replaceLeafsAsync(handler: AsyncLeafReplacer, bind?: unknown): Promise<ConditionTree>;
    match(record: RecordData, collection: Collection, timezone: string): boolean;
    override(params: Partial<PlainConditionTreeLeaf>): ConditionTreeLeaf;
    unnest(): ConditionTreeLeaf;
    /** @see https://stackoverflow.com/a/18418386/1897495 */
    private like;
}
export {};
//# sourceMappingURL=leaf.d.ts.map