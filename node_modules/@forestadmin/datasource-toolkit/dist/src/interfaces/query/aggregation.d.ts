import { RecordData } from '../record';
import { TCollectionName, TFieldName, TPartialFlatRow, TSchema } from '../templates';
import Projection from './projection';
export declare type AggregationOperation = 'Count' | 'Sum' | 'Avg' | 'Max' | 'Min';
export declare type DateOperation = 'Year' | 'Month' | 'Week' | 'Day';
export declare type AggregateResult<S extends TSchema = TSchema, N extends TCollectionName<S> = TCollectionName<S>> = {
    value: unknown;
    group: TPartialFlatRow<S, N>;
};
export interface PlainAggregation<S extends TSchema = TSchema, N extends TCollectionName<S> = TCollectionName<S>> {
    field?: TFieldName<S, N>;
    operation: AggregationOperation;
    groups?: Array<{
        field: TFieldName<S, N>;
        operation?: DateOperation;
    }>;
}
declare type GenericAggregation = {
    field?: string;
    operation: AggregationOperation;
    groups?: Array<{
        field: string;
        operation?: DateOperation;
    }>;
};
export default class Aggregation {
    field?: GenericAggregation['field'];
    operation: GenericAggregation['operation'];
    groups?: GenericAggregation['groups'];
    get projection(): Projection;
    constructor(components: GenericAggregation);
    apply(records: RecordData[], timezone: string, limit?: number): AggregateResult[];
    nest(prefix: string): Aggregation;
    replaceFields(handler: (field: string) => string): Aggregation;
    private createSummaries;
    private formatSummaries;
    private createGroup;
    private createSummary;
    private updateSummaryInPlace;
    private applyDateOperation;
}
export {};
//# sourceMappingURL=aggregation.d.ts.map