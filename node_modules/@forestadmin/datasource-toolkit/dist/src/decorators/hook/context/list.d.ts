import { Caller } from '../../../interfaces/caller';
import { Collection } from '../../../interfaces/collection';
import { RecordData } from '../../../interfaces/record';
import { TCollectionName, TFieldName, TRow, TSchema } from '../../../interfaces/templates';
import HookContext from './hook';
import PaginatedFilter, { PlainPaginatedFilter } from '../../../interfaces/query/filter/paginated';
import Projection from '../../../interfaces/query/projection';
export declare class HookBeforeListContext<S extends TSchema = TSchema, N extends TCollectionName<S> = TCollectionName<S>> extends HookContext<S, N> {
    protected _filter: PaginatedFilter;
    protected _projection: Projection;
    constructor(collection: Collection, caller: Caller, filter: PaginatedFilter, projection: Projection);
    get filter(): Readonly<PlainPaginatedFilter<S, N>>;
    get projection(): readonly TFieldName<S, N>[];
}
export declare class InternalHookBeforeListContext extends HookBeforeListContext {
    getFilter(): PaginatedFilter;
    getProjection(): Projection;
}
export declare class HookAfterListContext<S extends TSchema = TSchema, N extends TCollectionName<S> = TCollectionName<S>> extends HookBeforeListContext<S, N> {
    private _records;
    constructor(collection: Collection, caller: Caller, filter: PaginatedFilter, projection: Projection, records: RecordData[]);
    get records(): readonly TRow<S, N>[];
}
//# sourceMappingURL=list.d.ts.map