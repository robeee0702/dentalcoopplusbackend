import { Caller } from '../../../interfaces/caller';
import { Collection } from '../../../interfaces/collection';
import { CompositeId, RecordData } from '../../../interfaces/record';
import { PlainFilter } from '../../../interfaces/query/filter/unpaginated';
import { TCollectionName, TFieldName, TRow, TSchema } from '../../../interfaces/templates';
import CollectionCustomizationContext from '../../../context/collection-context';
export default class ActionContext<S extends TSchema = TSchema, N extends TCollectionName<S> = TCollectionName<S>> extends CollectionCustomizationContext<S, N> {
    readonly formValues: any;
    readonly filter: PlainFilter<S, N>;
    private queries;
    private projection;
    constructor(collection: Collection, caller: Caller, formValue: RecordData, filter: PlainFilter<S, N>, used?: Set<string>);
    /**
     * Get all the records selected by an action
     * @param fields An array of fields needed in the response
     * @example
     * .getRecords(['id', 'isActive', 'name']);
     */
    getRecords(fields: TFieldName<S, N>[]): Promise<TRow<S, N>[]>;
    /**
     * Get all the records ids selected by an action
     */
    getRecordIds(): Promise<Array<string | number>>;
    /**
     * Get all the records ids (when the collection uses composite keys)
     */
    getCompositeRecordIds(): Promise<CompositeId[]>;
    private runQuery;
    private reset;
}
//# sourceMappingURL=base.d.ts.map