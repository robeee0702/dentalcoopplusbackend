import { ActionField, ActionResult } from '../interfaces/action';
import { Caller } from '../interfaces/caller';
import { Collection, DataSource } from '../interfaces/collection';
import { CollectionSchema } from '../interfaces/schema';
import { RecordData } from '../interfaces/record';
import Aggregation, { AggregateResult } from '../interfaces/query/aggregation';
import Filter from '../interfaces/query/filter/unpaginated';
import PaginatedFilter from '../interfaces/query/filter/paginated';
import Projection from '../interfaces/query/projection';
export default class CollectionDecorator implements Collection {
    readonly dataSource: DataSource;
    protected childCollection: Collection;
    private lastSchema;
    private lastSubSchema;
    get schema(): CollectionSchema;
    get name(): string;
    constructor(childCollection: Collection, dataSource: DataSource);
    execute(caller: Caller, name: string, data: RecordData, filter?: Filter): Promise<ActionResult>;
    getForm(caller: Caller, name: string, data?: RecordData, filter?: Filter): Promise<ActionField[]>;
    create(caller: Caller, data: RecordData[]): Promise<RecordData[]>;
    list(caller: Caller, filter: PaginatedFilter, projection: Projection): Promise<RecordData[]>;
    update(caller: Caller, filter: Filter, patch: RecordData): Promise<void>;
    delete(caller: Caller, filter: Filter): Promise<void>;
    aggregate(caller: Caller, filter: Filter, aggregation: Aggregation, limit?: number): Promise<AggregateResult[]>;
    protected markSchemaAsDirty(): void;
    protected refineFilter(caller: Caller, filter?: PaginatedFilter): Promise<PaginatedFilter>;
    protected refineSchema(subSchema: CollectionSchema): CollectionSchema;
}
//# sourceMappingURL=collection-decorator.d.ts.map